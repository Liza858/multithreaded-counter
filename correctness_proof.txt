Покажем, что данный счетчик линеаризуем для модели памяти sequentially consistent.


Пусть счетчик -- массив из k чисел. Тогда операцию get() можно разложить на k операций чтения:
get() = read_1 + read_2 + ... + read_k (в цикле происходит k чтений и их результаты складываются)

Sequentially consistent модель памяти означает, что для всех операций чтения и записи (в любых потоках)
будут применяться все возможные барьеры памяти. Это также означает, что для всех последовательностей чтения и записи (из разных потоков в том числе) можно гарантировать линеаризуемость.


Тогда можно сказать, что в случае данного счетчика и sequentially consistent модели памяти
все операции чтения и инкремента будут линеаризуемы.
(инкремент в данном случае атомарный, его считаем за одну операцию, но все равно он состоит из двух операций: чтения и записи, поэтому
все барьеры памяти для него тоже будут применены)



(Например, пусть в 1 потоке была исполнена такая последовательность операций: [inc(), get()].
А во втором потоке: [inc()].

Пусть счетчик -- массив из двух чисел. Сначала counter = [0, 0].

Тогда get() можно разложить на две операции чтения: get() = read_1 + read_2.

Тогда можно сказать, что в 1 потоке последовательность операций такова: [inc(), read_1, read_2].

Операции read_1 и read_2 вернут какие-то значения.

И из модели памяти следует, что эти последовательности операций в двух потоках [inc(), read_1, read_2] и [inc()]
мы сможем линеаризовать -- исходя из результатов read_1 и read_2 привести эквивалентное последовательное исполнение.)



В общем случае. Пусть у нас есть z потоков, и пусть в i-ом потоке произошло x_i операций inc() и y_i операций
get(). В каком-то произвольном порядке. Пусть счетчик -- массив из k чисел. Для определенности будем считать, что до
запуска потоков он заполнен нулями: counter = [0, 0, ..., 0].

Построим линеаризацию для операций inc() и get().

Каждый j-ый get() в потоке i можно разложить на k операций чтения: get_i_j() = read_i_j_1 + read_i_j_2 + ... + read_i_j_k.

Из модели памяти следует линеаризуемость операций inc_i_q() и read_i_j_p, где q -- порядковый номер инкремента в потоке, p -- порядковый номер чтения для get_i_j().

Пусть S -- какая-то произвольная последовательность операций инкрементов и чтений.

Тогда возможная линеаризация для некоторых результатов read-ов будет выглядеть так:

[S_1, read_i_j_1, S_2, read_i_j_2, S_3, ..., S_k, read_i_j_k, S_k+1]

Пусть в последовательности S_1 находится m инкрементов. Тогда заметим, что read_i_j_1 + read_i_j_2 + ... + read_i_j_k >= m.

(мы увидим результаты всех этих инкрементов)

Также, пусть в последовательностях S_1, S_2, S_3, ..., S_k суммарно n инкрементов. Тогда: read_i_j_1 + read_i_j_2 + ... + read_i_j_k <= n.

(результаты каких-то инкрементов мы можем не увидеть, так как чтения происходят последовательно из массива counter.
Если, например некоторый инкремент увеличил ячейку counter[0], а мы её уже прочитали до этого инкремента, то результата мы не увидим)


Пусть read_i_j_1 + read_i_j_2 + ... + read_i_j_k = w, то есть get_i_j() = w,  m <= w <= n.

Тогда в исходной линеаризации [S_1, read_i_j_1, S_2, read_i_j_2, S_3, ..., S_k, read_i_j_k, S_k+1]
мы можем убрать все чтения от от read_i_j_1 до read_i_j_k и вставить get_i_j() в промежутке от read_i_j_1 до read_i_j_k
сразу после (w - m) инкрементов из последовательностей  S_2, S_3, ..., S_k. Это можно сделать, так как m <= get_i_j() <= n.

Таким образом можно из исходной линеаризации убрать все чтения и вставить get-ы для всех i и j и построить так линеаризацию для
для операций inc() и get().


Покажем, что данная линеаризация получится корректной.

Исходная линеаризация [S_1, read_i_j_1, S_2, read_i_j_2, S_3, ..., S_k, read_i_j_k, S_k+1]  была корректной, так она следовала из модели памяти. В ней порядок операций инкрементов и чтений для каждого отдельного потока сохранялся.

Теперь мы вставляем get_i_j() где-то между read_i_j_1 и read_i_j_k для всех i и j и убираем все read-ы.
Такая замена не приведет к нарушению порядка операций для каждого потока, так как между read_i_j_1 и read_i_j_k нет никаких
других операций потока i кроме чтений read_i_j_p -- и они все относятся к одному get -- get_i_j().
А значит полученная линеаризация будет корректной.


Таким образом, получилось построить линеаризацию для операций inc() и get() в общем случае, значит,
счетчик линеаризуем для модели памяти sequentially consistent.
